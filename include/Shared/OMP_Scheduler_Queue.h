#pragma once

#include <MPI_Scheduler.h>
#include "OMP_Scheduler.h"


template<typename Problem_Consts, typename Subproblem_Params, typename Domain_Type>
class OMP_Scheduler_Queue : public OMP_Scheduler<Problem_Consts, Subproblem_Params, Domain_Type> {
public:
    Subproblem_Params Execute(
            const Problem_Definition<Problem_Consts, Subproblem_Params, Domain_Type> &Problem_Def,
            const Problem_Consts &prob,
            const Goal goal,
            Domain_Type WorstBound) override;

private:
    void ThreadWork(
            const Problem_Definition<Problem_Consts, Subproblem_Params, Domain_Type> &Problem_Def,
            const Problem_Consts &prob,
            const Subproblem_Params &task,
            Subproblem_Params &CurrentBestProblem,
            Domain_Type &BestBound,
            std::deque<Subproblem_Params>& GlobalTaskQueue,
            const Goal goal,
            omp_lock_t& QueueLock);
    int TasksWorkedOn = 0;
    int TasksEliminated = 0;
};


template<typename Problem_Consts, typename Subproblem_Params, typename Domain_Type>
Subproblem_Params OMP_Scheduler_Queue<Problem_Consts, Subproblem_Params, Domain_Type>::Execute(
        const Problem_Definition<Problem_Consts, Subproblem_Params, Domain_Type> &Problem_Def,
        const Problem_Consts &prob,
        const Goal goal,
        Domain_Type WorstBound) {
    Subproblem_Params BestSubproblem;
    Domain_Type CurrentBestBound = WorstBound;
    std::deque<Subproblem_Params> GlobalTaskQueue;
    GlobalTaskQueue.push_back(Problem_Def.GetInitialSubproblem(prob));
    omp_lock_t QueueLock;
    omp_init_lock(&QueueLock);
    TasksWorkedOn = 0;
    TasksEliminated = 0;
    std::cout << "max threads: " << omp_get_max_threads() << std::endl;
        while (!GlobalTaskQueue.empty()) {
            int NumTasks = GlobalTaskQueue.size();
            TasksWorkedOn += NumTasks;

#pragma omp parallel for default(shared) schedule(static,1) num_threads(omp_get_max_threads()) shared(QueueLock, CurrentBestBound)
            for (int i = 0; i < NumTasks; i++) {
                omp_set_lock(&QueueLock);
                Subproblem_Params Task = GetNextSubproblem(GlobalTaskQueue, this->mode);
                omp_unset_lock(&QueueLock);

                ThreadWork(Problem_Def, prob, Task, BestSubproblem, CurrentBestBound, GlobalTaskQueue, goal, QueueLock);
            }
        }


/*
        std::move(GlobalTaskQueue.begin(), std::next(GlobalTaskQueue.begin(), NumToSpawn),
                  std::back_inserter(WorkPack));
        GlobalTaskQueue.erase(GlobalTaskQueue.begin(), std::next(GlobalTaskQueue.begin(), NumToSpawn));*/
    omp_destroy_lock(&QueueLock);
    std::cout << "There were " << TasksWorkedOn << " tasks generated by solving the problem" << std::endl;
    std::cout << "and so many were eliminated fast " << TasksEliminated<< std::endl;
    Problem_Def.PrintSolution(BestSubproblem);
    return BestSubproblem;
}


template<typename Problem_Consts, typename Subproblem_Params, typename Domain_Type>
void OMP_Scheduler_Queue<Problem_Consts, Subproblem_Params, Domain_Type>::ThreadWork(
        const Problem_Definition<Problem_Consts, Subproblem_Params, Domain_Type> &Problem_Def,
        const Problem_Consts &prob,
        const Subproblem_Params &task,
        Subproblem_Params &CurrentBestProblem,
        Domain_Type &CurrentBestBound,
        std::deque<Subproblem_Params>& GlobalTaskQueue,
        const Goal goal,
        omp_lock_t& QueueLock) {

    //ignore if its bound is worse than already known best sol.
    auto[LowerBound, UpperBound] = Problem_Def.GetEstimateForBounds(prob, task);
    if (((bool) goal && LowerBound < CurrentBestBound)
        || (!(bool) goal && LowerBound > CurrentBestBound)) {
        TasksEliminated++;
        return;
    }

    // try to make the bound better
    auto Feasibility = Problem_Def.IsFeasible(prob, task);
    Domain_Type CandidateBound;
    if (Feasibility == BnB::FEASIBILITY::Full) {
        CandidateBound = Problem_Def.GetContainedUpperBound(prob, task);
#pragma omp critical
        {
            if (((bool) goal && CandidateBound >= CurrentBestBound)
                || (!(bool) goal && CandidateBound <= CurrentBestBound)) {
                CurrentBestBound = CandidateBound;
                CurrentBestProblem = task;
            }
        }
    } else if (Feasibility == BnB::FEASIBILITY::PARTIAL) {
        CandidateBound = UpperBound;
    } else if (Feasibility == BnB::FEASIBILITY::NONE) {
        return;
    }

    // check if we cant divide further
    std::vector<Subproblem_Params> v;
    if (std::abs(CandidateBound - LowerBound) > this->eps) {
        v = Problem_Def.SplitSolution(prob, task);
        for (auto &&el : v) {
            omp_set_lock(&QueueLock);
            GlobalTaskQueue.push_back(el);
            omp_unset_lock(&QueueLock);
        }
    }
}



